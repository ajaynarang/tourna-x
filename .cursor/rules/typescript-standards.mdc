---
globs: *.ts,*.tsx
---

# TypeScript Standards for Tourna-X

## TypeScript Configuration
- Use TypeScript 5.9.2 with strict mode enabled
- Extend from `@repo/typescript-config` packages
- Enable all strict compiler options
- Use path aliases for clean imports

## Import Patterns

### Schema and Type Imports
```typescript
// Always import types from @repo/schemas
import { User, Tournament, Participant, Match } from '@repo/schemas';
import { COLLECTIONS } from '@repo/schemas';

// Use path aliases for local imports
import { connectToDatabase, getCollections } from '@/lib/mongodb';
import { usePageTitle } from '@/hooks/use-page-title';
import { Button } from '@/components/ui/button';
```

### MongoDB ObjectId Handling
```typescript
import { ObjectId } from 'mongodb';
import { objectIdSchema } from '@repo/schemas';

// Convert string to ObjectId
const userId = new ObjectId(userIdString);

// Validate ObjectId strings
const validId = objectIdSchema.parse(idString);
```

## Type Definitions

### API Response Types
```typescript
// Standard API response wrapper
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

// Pagination wrapper
interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  hasMore: boolean;
}
```

### Component Props
```typescript
// Use proper React types
interface ComponentProps {
  children: React.ReactNode;
  className?: string;
  onClick?: () => void;
}

// Event handlers
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  // Handle form submission
};
```

## Async/Await Patterns

### Database Operations
```typescript
// Always use async/await for database operations
export async function getTournament(id: string): Promise<Tournament | null> {
  try {
    const db = await connectToDatabase();
    const tournament = await db.collection(COLLECTIONS.TOURNAMENTS)
      .findOne({ _id: new ObjectId(id) });
    
    return tournament as Tournament | null;
  } catch (error) {
    console.error('Error fetching tournament:', error);
    throw error;
  }
}
```

### API Route Handlers
```typescript
// Next.js API route pattern
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    
    if (!id) {
      return NextResponse.json(
        { success: false, error: 'Missing tournament ID' },
        { status: 400 }
      );
    }
    
    const tournament = await getTournament(id);
    return NextResponse.json({ success: true, data: tournament });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

## Error Handling

### Try-Catch Patterns
```typescript
// Always wrap async operations in try-catch
async function createTournament(data: InsertTournament) {
  try {
    const db = await connectToDatabase();
    const result = await db.collection(COLLECTIONS.TOURNAMENTS)
      .insertOne(data);
    
    return { success: true, id: result.insertedId };
  } catch (error) {
    console.error('Error creating tournament:', error);
    return { success: false, error: 'Failed to create tournament' };
  }
}
```

## Type Guards and Validation

### Zod Schema Validation
```typescript
import { tournamentSchema, insertTournamentSchema } from '@repo/schemas';

// Validate data before processing
const validatedData = insertTournamentSchema.parse(requestData);

// Type-safe data access
if (validatedData.name && validatedData.sport) {
  // TypeScript knows these properties exist
}
```

## File Organization

### Component Files
```typescript
// components/ui/button.tsx
'use client'; // Only when needed

import React from 'react';
import { cn } from '@/lib/utils';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline';
  size?: 'default' | 'sm' | 'lg';
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'default', size = 'default', ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = 'Button';
```

### Hook Files
```typescript
// hooks/use-tournaments.ts
import { useQuery } from '@tanstack/react-query';
import { Tournament } from '@repo/schemas';

export function useTournaments() {
  return useQuery<Tournament[]>({
    queryKey: ['tournaments'],
    queryFn: async () => {
      const response = await fetch('/api/tournaments');
      const data = await response.json();
      return data.data || [];
    },
  });
}
```

## Best Practices
- Always use explicit return types for functions
- Prefer `interface` over `type` for object shapes
- Use `const assertions` for immutable data
- Leverage TypeScript's strict null checks
- Use proper generic constraints
- Avoid `any` type - use `unknown` instead when needed

Reference: [tsconfig.json](mdc:apps/frontend/tsconfig.json) for configuration details.